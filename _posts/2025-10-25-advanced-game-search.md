---
layout: post
title: "Advanced Game Search Algorithms (1)"
date: 2025-10-25
author: jinhan814
tags: [algorithm, game-theory, problem-solving]
---

## 1. Introduction

이번 글에서는 게임 에이전트의 가장 단순한 형태인 Random Agent부터 시작하여 Greedy, Minimax, Alpha-Beta Pruning의 핵심 원리를 다룹니다. 이후 이어지는 글에서는 MCTS 등의 현대적인 탐색 기법을 알아보고, NNUE 등의 neural network를 이용한 평가 방법과 여러 search prunning 방법을 살펴보겠습니다.

또한 에이전트의 성능을 객관적으로 평가하기 위해 SPRT(Sequential Probability Ratio Test)라는 평가 기법을 소개합니다. 이를 이용하면 통계적으로 두 에이전트 간의 실력 차이를 엄밀하게 검증할 수 있습니다.

이번 글에서 소개하는 방법론은 $2$인, 제로섬, 턴제, 완전정보, 결정론적 전이를 만족하는 게임에 적용이 가능하며, 구체적인 설명을 위해서 ATAXX를 예시로 각 알고리즘을 구현해보겠습니다.

## 2. ATAXX

게임 에이전트를 구현하는 방법을 알아보기에 앞서, 예시로 들 게임의 규칙을 먼저 소개하겠습니다.

### 2-1. 게임 규칙

ATAXX는 $7 \times 7$ 보드에서 진행되는 $2$인 턴제 게임입니다.

![Fig.1](/assets/images/2025-10-25-advanced-game-search/fig1_v4.png)

선공 플레이어는 $(1, 1), (7, 7)$ 위치에 두 개의 돌을 가지고 있고, 후공 플레이어는 $(1, 7)$, $(7, 1)$ 위치에 두 개의 돌을 가지고 있습니다. 나머지 $45$개의 칸은 모두 빈 칸입니다.

게임은 두 플레이어가 번갈아가며 본인의 돌이 놓여있는 시작 칸 $(x_1, y_1)$과 비어있는 도착 칸 $(x_2, y_2)$를 고르며 진행됩니다.

각 턴마다 게임이 진행되는 방식은 다음과 같습니다.

- 이동 거리 $d = \max(|x_2 - x_1|, |y_2 - y_1|)$는 $1$ 또는 $2$여야 합니다.
- 이동 거리가 $1$인 경우는 시작 칸의 돌이 그대로 남고 도착 칸에만 자신의 돌이 새로 생깁니다.
- 이동 거리가 $2$인 경우는 시작 칸의 돌이 도착 칸으로 이동합니다.
- 도착 칸 $(x_2, y_2)$를 기준으로 $8$방향(상하좌우, 대각선)으로 인접한 칸에 상대의 돌이 있다면, 해당 칸을 자신의 돌로 바꿉니다.
- 자신의 턴에 고를 수 있는 $(x_1, y_1), (x_2, y_2)$가 없다면 `PASS`를 선택하며, 이 경우에는 아무 변화 없이 상대에게로 턴이 넘어갑니다.

정리하면, 각 플레이어는 이동거리가 $1$ 또는 $2$인 $(x_1, y_1), (x_2, y_2)$를 골라 턴을 진행하며, 고를 수 있는 행동이 없다면 `PASS`를 선택해 턴을 넘깁니다.

다음은 선공 플레이어가 $(1, 1)$에서 $(2, 2)$로 이동 거리가 $1$인 행동을 수행하는 예시입니다.

![Fig.2](/assets/images/2025-10-25-advanced-game-search/fig2_v3.png)

다음은 후공 플레이어가 $(2, 2)$에서 $(4, 4)$로 이동 거리가 $2$인 행동을 수행하는 예시입니다.

![Fig.3](/assets/images/2025-10-25-advanced-game-search/fig3_v3.png)

마지막으로 다음은 선공 플레이어가 `PASS`를 선택하는 예시입니다.

![Fig.4](/assets/images/2025-10-25-advanced-game-search/fig4_v3.png)

게임은 다음 조건 중 하나가 만족되면 종료됩니다.

- 어느 한 플레이어의 돌이 보드에서 완전히 사라졌을 때
- 보드에 남은 빈 칸이 하나도 없을 때
- 두 플레이어가 모두 $200$번씩 총 $400$턴을 수행했을 때

종료 시점에 돌이 더 많은 플레이어가 승리하며, 만약 두 플레이어의 돌 개수가 같다면 무승부로 마무리합니다.

여기까지가 ATAXX 게임의 룰입니다. 이때 $400$턴을 초과하면 게임을 종료한다는 규칙은 게임이 무한히 길어지는 걸 방지하기 위해 제가 임의로 추가했습니다. 다른 플렛폼에서는 $3$회 동형, $50$수 규칙 등을 채택할 수 있음에 주의해주세요.

해당 게임은 [링크](https://alphano.co.kr/problem/1/play)에서 플레이해볼 수 있습니다.

### 2-2. 입출력 형식

이제 에이전트와 심판 프로그램 간의 상호작용 규칙을 정의하겠습니다.

| 명령어 | 심판→에이전트(입력) | 에이전트→심판 (출력) | 시간 제한(ms) | 설명 |
|:--|:--|:--|:--|:--|
| **READY** | `READY (FIRST \| SECOND)` | `OK` | `3000` | 선공/후공 정보를 알립니다. |
| **TURN** | `TURN my_time opp_time` | `MOVE x1 y1 x2 y2` | `my_time` | 내 남은 시간과 상대의 남은 시간을 알립니다. 이번 턴에 내가 선택한 수의 $(x_1, y_1)$, $(x_2, y_2)$를 출력합니다. `PASS`를 선택한 경우는 `MOVE -1 -1 -1 -1`을 출력합니다. |
| **OPP** | `OPP x1 y1 x2 y2 time` | - | - | 상대가 직전에 둔 수와 사용한 시간을 알립니다. 상대가 `PASS`를 선택한 경우는 `OPP -1 -1 -1 -1 time`이 입력됩니다. |
| **FINISH** | `FINISH` | - | - | 게임 종료를 알립니다. 에이전트는 추가 출력 없이 프로그램을 정상 종료해야 합니다. |

각 에이전트의 제한 시간은 게임 당 `10000ms`로 주어지고, 에이전트는 주어진 총 시간을 잘 분배해서 사용해야 합니다.

## 3. Random Agent

~

## 4. Greedy Agent

~

## 5. SPRT(Sequential Probability Ratio Test)

~

## 6. Minimax Algorithm

~

## 7. Alpha-Beta Prunning

~

## 8. Summary

~

## References

[1] [https://en.wikipedia.org/wiki/Ataxx](https://en.wikipedia.org/wiki/Ataxx)